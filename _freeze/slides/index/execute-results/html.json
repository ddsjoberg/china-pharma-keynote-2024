{
  "hash": "1c6e8adec576aafd92c685cc546a8192",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"CDISC Analysis Results Data with {cards} + {gtsummary}\"\nauthor: \"Daniel D. Sjoberg\"\nfooter:  \"[CDISC Analysis Results Data with {cards}+{gtsummary}](https://www.danieldsjoberg.com/china-pharma-keynote-2024/)\"\nlogo: \"images/v2-gtsummary-cards-cardx-HexSticker.png\"\neditor: source\nengine: knitr\nformat: \n  revealjs: \n    theme: slides.scss\n    transition: fade\n    slide-number: true\n    chalkboard: true\nexecute:\n  echo: true\n  freeze: auto\ncache: true\n---\n\n\n# Introduction\n\n\n::: {.cell}\n\n:::\n\n\n\n<!-- {{< include 00-setup.qmd >}} -->\n\n<!-- {{< include 01-ars.qmd >}} -->\n\n<!-- {{< include 02-ard.qmd >}} -->\n\n<!-- {{< include 03-cards.qmd >}} -->\n\n# {cardx} \n\n## {cardx} R Package <a href=\"https://insightsengineering.github.io/cardx/\"><img src=\"https://insightsengineering.github.io/cardx/latest-tag/logo.png\" align=\"right\" height=\"138\" alt=\"cardx website\" /></a>\n\n- While {cards} performs basic (and very common) summaries, {cardx} exports `ard_*()` functions for more complex analytic results.\n\n- The list is growing, but we have functions for t-tests, Wilcoxon tests, standardized mean differences, ANOVA (including repeated measures), survey methods, confidence intervals for proportions and centrality estimates, and more.\n\n- Elegant solution for nearly every regression model type in the R ecosystem, where we can identify regression types (linear, logistic, Cox, etc.), identify the underlying variable names for categorical variables (different from the model terms), identify reference groups for categorical variables, and much much more.\n\n::: {.notes}\n\nYes, this is also a draft hex sticker!\n\n:::\n\n## {cardx}\n\nSupported regression model types include:\n\n::: {.small}\n\n`betareg::betareg()`, `biglm::bigglm()`, `biglmm::bigglm()`, `brms::brm()`, `cmprsk::crr()`, `fixest::feglm()`, `fixest::femlm()`, `fixest::feNmlm()`, `fixest::feols()`, `gam::gam()`, `geepack::geeglm()`, `glmmTMB::glmmTMB()`, `lavaan::lavaan()`, `lfe::felm()`, `lme4::glmer.nb()`, `lme4::glmer()`, `lme4::lmer()`, `logitr::logitr()`, `MASS::glm.nb()`, `MASS::polr()`, `mgcv::gam()`, `mice::mira`, `mmrm::mmrm()`, `multgee::nomLORgee()`, `multgee::ordLORgee()`, `nnet::multinom()`, `ordinal::clm()`, `ordinal::clmm()`, `parsnip::model_fit`, `plm::plm()`, `pscl::hurdle()`, `pscl::zeroinfl()`, `rstanarm::stan_glm()`, `stats::aov()`, `stats::glm()`, `stats::lm()`, `stats::nls()`, `survey::svycoxph()`, `survey::svyglm()`, `survey::svyolr()`, `survival::cch()`, `survival::clogit()`, `survival::coxph()`, `survival::survreg()`, `tidycmprsk::crr()`, `VGAM::vglm()`.\n\n:::\n\n## {cardx} in Practice\n\nIn the example below, we're adding a confidence interval around the rate of subjects who completed the study.\n\nWe're using the default computation method (Wald) and confidence level (95%).\n\n::: {.cell}\n\n```{.r .cell-code}\nADSL |> \n  dplyr::mutate(COMPLETED = DCDECOD == \"COMPLETED\") |> \n  ard_proportion_ci(variables = COMPLETED) # using default CI method 'Wald'\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n{cards} data frame: 6 x 8\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   variable   context  stat_name stat_label      stat fmt_fn\n1 COMPLETED proportiâ€¦          N          N       254      0\n2 COMPLETED proportiâ€¦   estimate   estimate     0.433      1\n3 COMPLETED proportiâ€¦   conf.low   conf.low      0.37      1\n4 COMPLETED proportiâ€¦  conf.high  conf.high     0.496      1\n5 COMPLETED proportiâ€¦ conf.level  conf.levâ€¦      0.95      1\n6 COMPLETED proportiâ€¦     method     method Wald Conâ€¦   <fn>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nâ„¹ 2 more variables: warning, error\n```\n\n\n:::\n:::\n\n## {cardx} in Practice: _Gone Wrong_ ðŸ˜±\n\nWhat happens when statistics are un-calculable? \n\n(It's one of my favorite features of {cards} and {cardx})\n\n::: {.cell}\n\n```{.r .cell-code}\nard_gone_wrong <- ADSL |> \n  ard_continuous(\n    variable = AGEGR1,\n    statistic = ~list(kurtosis = \\(x) e1071::kurtosis(x, na.rm = TRUE))\n  )\nard_gone_wrong\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n{cards} data frame: 1 x 8\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  variable stat_name stat_label stat   warning     error\n1   AGEGR1  kurtosis   kurtosis      argumentâ€¦ non-numeâ€¦\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nâ„¹ 2 more variables: context, fmt_fn\n```\n\n\n:::\n:::\n\n::: {.fragment}\n\n```r\nprint_ard_conditions(ard_gone_wrong)\n```\n\n![](images/ard-error-msg.png)\n\n:::\n\n::: {.notes}\n\n- Even when there are errors or warnings, we still get the ARD with the expected structure returned.\n\n  - THIS IS BIG! There are MANY circumstances, when you are designing TLGs early in a study when you do not have all the data required to calculate every statistic.\n  \n  - This allows you to design everything up-front.\n  \n- We can also report these warnings and errors back to users. <!CLICK!>\n\n:::\n\n# {gtsummary} \n\n## {gtsummary} R Package <a href=\"https://ddsjoberg.github.io/gtsummary/\"><img src=\"https://ddsjoberg.github.io/gtsummary/logo.png\" align=\"right\" height=\"138\" alt=\"gtsummary website\" /></a>\n\n- Talk about the success of gtsummary\n\n  - most downloaded summary table package on CRAN\n  \n  - composable tables make it very popular. it makes it easy create bespoke tables\n  \n  - tables output to gt, flextable, huxtable, kableExtra, kable, and even tibbles/data frames. meaning that you can utilize any printing engine for your needed output type (each of them have their strengths)\n  \n## gtsummary+cards\n\nthen move on to how {cards} and {gtsummary} can work together.\n\n- The {cards} package does not present results and this is where the {gtsummary} package shines.\n\n- The {gtsummary} package offers a modular framework to construct summary tables. \n\n- The {gtsummary} package is the most widely used package for summary tables in the R ecosystem, and won the American Statistical Associationâ€™s 2021 award for Innovation in Statistical Programming and Analytics and itâ€™s currently being refactored with a {cards} backend.\n\n## gtsummary+cards\n\n![](images/ard-gtsummary-workflow.png)\n\n## final slides\n\nHow best to end this presentation?\n  \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}